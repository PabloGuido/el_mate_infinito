local sprite_frente = hash("frente")
local sprite_frente_idle = hash("frente_idle")
local sprite_dorso = hash("dorso")
local sprite_dorso_idle = hash("dorso_idle")
local sprite_derecha = hash("derecha")
local sprite_derecha_idle = hash("derecha_idle")
local sprite_izquierda = hash("izquierda")
local sprite_izquierda_idle = hash("izquierda_idle")

-- datos varios necesarios para el juego
local datos = require("main.datos")

-- Módulo del inventario
local inventario = require("main.inventario")

-- Traer el modulo de la cámara ortográfica
local camera = require("orthographic.camera")
local url_de_camara = "/camera"

-- Esta función envía un mensaje para que la cámara empiece a seguir al player.
local function mensaje_camera_seguir_player () 
	msg.post(url_de_camara, "follow", {
		target = go.get_id(),
		lerp = 0.1,
		offset = vmath.vector3(0,0,0),
		horizontal = true,
		vertical = true,
	})
	msg.post(url_de_camara, "use_projection", { projection = hash("FIXED_AUTO") })
end

-- función para mover la cámara en el mapa.
local camara_moviendose = false
local function mover_camara (otro_objeto, otro_posicion, normal)
	local mover_x = 216
	local mover_y = 192
	local objeto_de_transicion = otro_objeto
	local mover_objeto_de_transicion = 18
	local posicion_objeto_de_transicion = otro_posicion
	local colision_normal = normal

	local posicion_de_la_camara = go.get_position(url_de_camara)

	go.set_position(vmath.vector3(posicion_de_la_camara.x - colision_normal.x * mover_x, posicion_de_la_camara.y - colision_normal.y * mover_y, posicion_de_la_camara.z) ,url_de_camara)
	local p = go.get_position()
	local new_p = vmath.vector3(p.x - colision_normal.x * 18, p.y - colision_normal.y * 18, p.z)
	go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, new_p, go.EASING_LINEAR, 0.25, 0, function() camara_moviendose = false end)
end

local function parpadeo (self)
	--if self.tiempo_parado_sobre_vacio >= 1 then
		msg.post(".", "release_input_focus")
		local p = go.get_position()
		go.set_position(vmath.vector3(self.ultima_plataforma_segura.x, self.ultima_plataforma_segura.y, p.z))
		self.parado_sobre_vacio = false
		self.tiempo_parado_sobre_vacio = 0
		go.set("#sprite", "tint.w", 0)
		msg.post(".", "acquire_input_focus")
		go.animate("#sprite", "tint.w", go.PLAYBACK_LOOP_FORWARD, 1, go.EASING_LINEAR, 0.2)
		timer.delay(1, false, function()
			go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 0.2)
		end)
	--end
end

local function draw_line(from, to)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(0,0,0,0) })
end

function init(self)
	print("Inicializando player")
	-- Variables para la velocidad y dirección donde apunta el player.
	self.velocidad_por_defecto = 50
	self.velocidad_de_movimiento = self.velocidad_por_defecto
	self.direccion_donde_apunta_player = vmath.vector3()
	self.ultima_direccion_donde_apunto_player = vmath.vector3(0, -1, 0)
	self.ultima_plataforma_segura = vmath.vector3()
	self.tiempo_parado_sobre_vacio = 0
	--self.animacion_del_player = hash("player_abajo")
	self.ultima_animacion = sprite_frente_idle
	self.ultima_animacion_direccion = vmath.vector3()
	-- Variables para el raycast.
	self.longitud_del_raycast = 12
	self.to = vmath.vector3(0, -self.longitud_del_raycast, 0)

	-- Variables para ver sobre donde está parado el player cuando sea necesario.
	self.parado_sobre_plataforma = false
	self.parado_sobre_vacio = false

	-- Variables para la embestida.
	self.presionando_tecla_de_embestida = false
	self.carga_de_embestida = 0
	self.sonando_carga_de_embestida = false
	self.embestida_cargada_sonido = false
	self.embistiendo = false
	--Objeto destruido/embestido
	self.objeto_destruido = false	
	-- musica
	

	-- cosas de la camara y raycast ?
	--mensaje_camera_seguir_player ()
	msg.post(url_de_camara, "use_projection", { projection = hash("FIXED_AUTO") })
	msg.post(url_de_camara, "zoom_to", {zoom = 3.5})


	if datos.primera_vez_que_se_inicia_el_player == true then -- poner el caso cuando no es la primera vez
		datos.primera_vez_que_se_inicia_el_player = false
		go.set("/mapa_01#mapa_01", "tint.w", 0)
			go.set("#sprite", "tint.w", 0)
		go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 3, 2, 
		function()
			go.animate("/mapa_01#mapa_01", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 1.5, 0, function() msg.post(".", "acquire_input_focus") end)
		end)
	else
		go.set("#sprite", "tint.w", 0)
		-- cambiar los primeros dos ceros por el tiempo que haga falta para arrancar nuevo mapa
		go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 0.5, 0.1,function() msg.post(".", "acquire_input_focus") end)
	end

end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Movimiento del player
	if vmath.length_sqr(self.direccion_donde_apunta_player) > 1 then
		self.direccion_donde_apunta_player = vmath.normalize(self.direccion_donde_apunta_player) -- (1)
	end

	if self.presionando_tecla_de_embestida == true then --hbaría que poner sprites de salto quizá
		self.direccion_donde_apunta_player = vmath.vector3()
		if self.ultima_direccion_donde_apunto_player.x > 0 then
			self.ultima_animacion = sprite_derecha_idle
			anim = sprite_derecha_idle
		elseif self.ultima_direccion_donde_apunto_player.x < 0 then
			self.ultima_animacion = sprite_izquierda_idle
			anim = sprite_izquierda_idle
		elseif self.ultima_direccion_donde_apunto_player.y > 0 then
			self.ultima_animacion = sprite_dorso_idle
			anim = sprite_dorso_idle
		elseif self.ultima_direccion_donde_apunto_player.y < 0 then
			self.ultima_animacion = sprite_frente_idle
			anim = sprite_frente_idle
		end
	end

	-- animacion del player 
	local anim = self.ultima_animacion

	if self.direccion_donde_apunta_player.x > 0 then
		anim = sprite_derecha
		self.ultima_animacion = sprite_derecha_idle
	elseif self.direccion_donde_apunta_player.x < 0 then
		anim = sprite_izquierda
		self.ultima_animacion = sprite_izquierda_idle
	elseif self.direccion_donde_apunta_player.y > 0 then
		anim = sprite_dorso
		self.ultima_animacion = sprite_dorso_idle
	elseif self.direccion_donde_apunta_player.y < 0 then
		anim = sprite_frente
		self.ultima_animacion = sprite_frente_idle
	end

	if anim ~= self.animacion_del_player then
		msg.post("#sprite", "play_animation", { id = anim })
		self.animacion_del_player = anim
	end

	-- fin de la animación 

	local posicion_nueva = self.direccion_donde_apunta_player * self.velocidad_de_movimiento * dt -- (2)
	local posicion_actual = go.get_position()
	vmath.vector3(posicion_actual.x, posicion_actual.y - 5, posicion_actual.z)
	draw_line(vmath.vector3(posicion_actual.x, posicion_actual.y - 5, posicion_actual.z), vmath.vector3(posicion_actual.x, posicion_actual.y - 5, posicion_actual.z) + self.to)


	go.set_position(posicion_actual + posicion_nueva) -- (3)

	if self.embistiendo == false then
		self.direccion_donde_apunta_player = vmath.vector3() -- (4)
	end
	-- 1) Normaliza el vector para el movimiento en diagonal.
	-- 2) Cálculo para nueva posicion en delta time.
	-- 3) Mover al player como resultado de la suma de la posicion actual y la nueva.
	-- 4) Restaurar la dirección del player para cuando ya deje de moverse.

	if self.parado_sobre_vacio == true then
		self.tiempo_parado_sobre_vacio = self.tiempo_parado_sobre_vacio + 1
		if self.parado_sobre_plataforma == true then 
			self.tiempo_parado_sobre_vacio = 0
		elseif self.tiempo_parado_sobre_vacio >= 8 then
			-- usar esto para enviar al player a la ultima posicion segura
			parpadeo(self)
		end
		--print(self.tiempo_parado_sobre_vacio)
		self.parado_sobre_vacio = false
	end
end

function on_message(self, message_id, message, sender)

	if message_id == hash("trigger_response") then
		if message.enter == true and message.other_group == hash("plataforma") then
			self.parado_sobre_plataforma = true
		elseif message.enter == false and message.other_group == hash("plataforma") then
			self.parado_sobre_plataforma = false
	--[[
		elseif message.other_group == hash("vacio") and message.enter then
			--self.parado_sobre_vacio = true
		elseif message.other_group == hash("vacio") and message.enter == false then
			--print("saliendo")
			--self.tiempo_parado_sobre_vacio = 0
			--self.parado_sobre_vacio = false
	]]
		elseif message.other_group == hash("camara") and message.enter == true then
			pprint(message)
		end
	elseif message_id == hash("contact_point_response") then
		-- cálculo para resolver la colision del player con las paredes y rocas.
		if message.other_group == hash("pared") then
			local newpos = go.get_position() + message.normal * message.distance
			go.set_position(newpos)
		elseif message.other_group == hash("objeto") then
				local newpos = go.get_position() + message.normal * message.distance
				go.set_position(newpos)
		elseif message.other_group == hash("roca") then
			local newpos = go.get_position() + message.normal * message.distance
			go.set_position(newpos)
		elseif	message.other_group == hash("rompible") then
			local newpos = go.get_position() + message.normal * message.distance
			go.set_position(newpos)
		elseif message.other_group == hash("vacio") then
			self.parado_sobre_vacio = true
		elseif message.other_group == hash("camara") then
			if camara_moviendose == false then
				camara_moviendose = true
				mover_camara (message.other_id, message.other_position, message.normal)
			end
		
		end

	elseif message_id == hash("rompible_responde") then
		self.objeto_destruido = true
		self.velocidad_de_movimiento = self.velocidad_por_defecto 
		self.carga_de_embestida = 0 
		self.embistiendo = false 
		msg.post(".", "acquire_input_focus") 
		go.set_position(vmath.vector3(0,-5,-0.25), "charge") 
		timer.delay(0.1, false, function() self.objeto_destruido = false end)
	elseif message_id == hash("player_recobra_input") then
		msg.post(".", "acquire_input_focus")
	elseif message_id == hash("plataforma_segura") then
		self.ultima_plataforma_segura = message.posicion
	end
end

function on_input(self, action_id, action)
if action_id == hash("derecha") then
		self.direccion_donde_apunta_player.x = 1
		self.ultima_direccion_donde_apunto_player.x = self.direccion_donde_apunta_player.x
		self.ultima_direccion_donde_apunto_player.y = 0
		self.to = vmath.vector3(self.longitud_del_raycast, 0, 0)
	elseif action_id == hash("izquierda") then
		self.direccion_donde_apunta_player.x = -1
		self.ultima_direccion_donde_apunto_player.x = self.direccion_donde_apunta_player.x 
		self.ultima_direccion_donde_apunto_player.y = 0
		self.to = vmath.vector3(-self.longitud_del_raycast, 0, 0)
	elseif action_id == hash("arriba") then -- input de direcciones "X" e "Y" con sus correspondientes sprites.
		self.direccion_donde_apunta_player.y = 1
		self.ultima_direccion_donde_apunto_player.y = self.direccion_donde_apunta_player.y 
		self.ultima_direccion_donde_apunto_player.x = 0
		self.to = vmath.vector3(0, self.longitud_del_raycast, 0) -- para el draw line
	elseif action_id == hash("abajo") then
		self.direccion_donde_apunta_player.y = -1
		self.ultima_direccion_donde_apunto_player.y = self.direccion_donde_apunta_player.y 
		self.ultima_direccion_donde_apunto_player.x = 0
		self.to = vmath.vector3(0, -self.longitud_del_raycast, 0)


elseif action_id == hash("charge") then
	if datos.player_puede_saltar == true then
		self.embistiendo = true

		if action.released == false then
			self.presionando_tecla_de_embestida = true
			self.carga_de_embestida = self.carga_de_embestida + 1
			--print(self.charge)
			if self.carga_de_embestida >= 50 then

				if self.embestida_cargada_sonido == false then
					self.embestida_cargada_sonido = true
					sound.play("#embestida_cargada")
				end

			elseif self.carga_de_embestida >= 25 then
				if self.sonando_carga_de_embestida == false then
					self.sonando_carga_de_embestida = true
					sound.play("#charging")
					particlefx.play("#charging1")
				end

			end

		elseif action.released == true then
			self.presionando_tecla_de_embestida = false

			if self.carga_de_embestida <= 50 then
				msg.post(".", "release_input_focus")
				self.sonando_carga_de_embestida = false
				sound.stop("#charging")
				particlefx.stop("#charging1")
				self.carga_de_embestida = 0

				if self.direccion_donde_apunta_player == vmath.vector3() then
					self.direccion_donde_apunta_player = self.ultima_direccion_donde_apunto_player
				end

				sound.play("#dash")
				
				self.velocidad_de_movimiento = 230
				timer.delay(0.1, false,
				function()
					self.velocidad_de_movimiento = self.velocidad_por_defecto
					msg.post(".", "acquire_input_focus")
					self.embistiendo = false 
				end)

			elseif self.carga_de_embestida >= 50 then
				sound.play("#charging_swipe")
				--print("CHARGING!!!")
				msg.post(".", "release_input_focus")
				self.embestida_cargada_sonido = false
				self.sonando_carga_de_embestida = false
				sound.stop("#charging")
				particlefx.stop("#charging1")
				if self.direccion_donde_apunta_player == vmath.vector3() then
					self.direccion_donde_apunta_player = self.ultima_direccion_donde_apunto_player
				end
				go.set_position(self.ultima_direccion_donde_apunto_player * 8, "charge") -- mueve el charge collition
				self.velocidad_de_movimiento = 475

				timer.delay(0.1, false, 
				function()
					if self.objeto_destruido == false then 
						self.embistiendo = false 
						self.velocidad_de_movimiento = self.velocidad_por_defecto 
						self.carga_de_embestida = 0 
						msg.post(".", "acquire_input_focus") 
						go.set_position(vmath.vector3(0,-5,-0.25), "charge") 
					end
				end)

			end

		end
	end
	
elseif action_id == hash("fisicas_debug") and action.pressed then 
	-- "F", prende/apaga el debug de los objetos físicos. 
	msg.post("@system:", "toggle_physics_debug")
elseif action_id == hash("pos") and action.pressed then
	-- Muestra la posicion actual en la consola.
	print(go.get_position())
elseif action_id == hash("accion") and action.pressed then
	local pos_player = go.get_position()
	local pos_inicial_ray = vmath.vector3(pos_player.x, pos_player.y - 5, pos_player.z)
	local result = physics.raycast(pos_inicial_ray, pos_inicial_ray + self.to, { hash("objeto"), hash("roca") })
	if result then
		self.sonando_carga_de_embestida = false
		sound.stop("#charging")
		particlefx.stop("#charging1")
		self.carga_de_embestida = 0
		msg.post(".", "release_input_focus")
		msg.post(result.id, "player_interactuando_con_objeto", {normal = result.normal})
	end
elseif action_id == hash("inventario") and action.pressed then
	print("--- INVENTARIO ---")
	for k, v in pairs(inventario) do

		print(k .. ":", v)

	end
	print("--- XXXXXXXXXX ---")
end

end

function on_reload(self)
-- Add reload-handling code here
-- Learn more: https://defold.com/manuals/hot-reload/
-- Remove this function if not needed
end
