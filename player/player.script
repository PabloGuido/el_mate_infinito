local sprite_frente = hash("pj")
local sprite_frente_idle = hash("pj")
local sprite_dorso = hash("pj")
local sprite_dorso_idle = hash("pj")
local sprite_derecha = hash("pj")
local sprite_derecha_idle = hash("pj")
local sprite_izquierda = hash("pj")
local sprite_izquierda_idle = hash("pj")


local datos = require("main.datos")

-- Módulo del inventario
local inventario = require("main.inventario")

-- Traer el modulo de la cámara ortográfica
local camera = require("orthographic.camera")
local url_de_camara = "/camera"

-- Esta función envía un mensaje para que la cámara empiece a seguir al player.
local function mensaje_camera_seguir_player () 
	msg.post(url_de_camara, "follow", {
		target = go.get_id(),
		lerp = 0.1,
		offset = vmath.vector3(0,0,0),
		horizontal = true,
		vertical = true,
	})
	msg.post(url_de_camara, "use_projection", { projection = hash("FIXED_AUTO") })
end

-- función para mover la cámara en el mapa.
local test = false
local function mover_camara (otro_objeto, otro_posicion, normal)
	local mover_x = 216
	local mover_y = 192
	local objeto_de_transicion = otro_objeto
	local mover_objeto_de_transicion = 18
	local posicion_objeto_de_transicion = otro_posicion
	local colision_normal = normal

	local posicion_de_la_camara = go.get_position(url_de_camara)

	go.set_position(vmath.vector3(posicion_de_la_camara.x - colision_normal.x * mover_x, posicion_de_la_camara.y - colision_normal.y * mover_y, posicion_de_la_camara.z) ,url_de_camara)
	--print(objeto_de_transicion)

	--go.set_position(vmath.vector3(posicion_objeto_de_transicion.x + colision_normal.x * mover_objeto_de_transicion, posicion_objeto_de_transicion.y + colision_normal.y * mover_objeto_de_transicion, posicion_objeto_de_transicion.z), objeto_de_transicion)
	--test = false
	--timer.delay(1, false, function() test = false end)
	local p = go.get_position()
	local new_p = vmath.vector3(p.x - colision_normal.x * 18, p.y - colision_normal.y * 18, p.z)
	go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, new_p, go.EASING_LINEAR, 0.25, 0, function() test = false end)
end

local function draw_line(from, to)
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(0,0,0,0) })
end

function init(self)	
	print("Inicializando player")
	-- Variables para la velocidad y dirección donde apunta el player.
	self.velocidad_por_defecto = 50
	self.velocidad_de_movimiento = self.velocidad_por_defecto
	self.direccion_donde_apunta_player = vmath.vector3()
	self.ultima_direccion_donde_apunto_player = vmath.vector3(0, -1, 0)
	--self.animacion_del_player = hash("player_abajo")
	self.ultima_animacion = sprite_frente_idle

	-- Variables para el raycast.
	self.longitud_del_raycast = 8
	self.to = vmath.vector3(0, -self.longitud_del_raycast, 0)

	-- Variables para ver sobre donde está parado el player cuando sea necesario.
	self.parado_sobre_plataforma = false
	self.parado_sobre_vacio = false

	-- Variables para la embestida.
	self.presionando_tecla_de_embestida = false
	self.carga_de_embestida = 0
	self.sonando_carga_de_embestida = false
	self.embestida_cargada_sonido = false
	self.embistiendo = false
	--Objeto destruido/embestido
	self.objeto_destruido = false	

	-- cosas de la camara y raycast ?
	--mensaje_camera_seguir_player ()
	msg.post(url_de_camara, "use_projection", { projection = hash("FIXED_AUTO") })
	msg.post(url_de_camara, "zoom_to", {zoom = 3.5})


	if datos.primera_vez_que_se_inicia_el_player == true then -- poner el caso cuando no es la primera vez
		datos.primera_vez_que_se_inicia_el_player = false
			go.set("/mapa_01#mapa_01", "tint.w", 0)
			go.set("#sprite", "tint.w", 0)
		go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 3, 2, 
		function()
			go.animate("/mapa_01#mapa_01", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 1.5, 0, function() msg.post(".", "acquire_input_focus") end)
		end)
	else
		go.set("#sprite", "tint.w", 0)
		-- cambiar los primeros dos ceros por el tiempo que haga falta para arrancar nuevo mapa
		go.animate("#sprite", "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, 2, 0.1,function() msg.post(".", "acquire_input_focus") end)
	end


	--msg.post(".", "acquire_input_focus") -- habilitar input

end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Movimiento del player
	if vmath.length_sqr(self.direccion_donde_apunta_player) > 1 then
		self.direccion_donde_apunta_player = vmath.normalize(self.direccion_donde_apunta_player) -- (1)
	end

	if self.presionando_tecla_de_embestida == true then
		self.direccion_donde_apunta_player = vmath.vector3()
		if self.ultima_direccion_donde_apunto_player.x > 0 then
			self.ultima_animacion = sprite_derecha_idle
		elseif self.ultima_direccion_donde_apunto_player.x < 0 then
			self.ultima_animacion = sprite_izquierda_idle
		elseif self.ultima_direccion_donde_apunto_player.y > 0 then
			self.ultima_animacion = sprite_dorso_idle
		elseif self.ultima_direccion_donde_apunto_player.y < 0 then
			self.ultima_animacion = sprite_frente_idle
		end
	end

	-- animacion del player 
	local anim = self.ultima_animacion

	if self.direccion_donde_apunta_player.x > 0 then
		anim = sprite_derecha
		self.ultima_animacion = sprite_derecha_idle
	elseif self.direccion_donde_apunta_player.x < 0 then
		anim = sprite_izquierda
		self.ultima_animacion = sprite_izquierda_idle
	elseif self.direccion_donde_apunta_player.y > 0 then
		anim = sprite_dorso
		self.ultima_animacion = sprite_dorso_idle
	elseif self.direccion_donde_apunta_player.y < 0 then
		anim = sprite_frente
		self.ultima_animacion = sprite_frente_idle
	end

	if anim ~= self.animacion_del_player then
		msg.post("#sprite", "play_animation", { id = anim })
		self.animacion_del_player = anim
	end

	-- fin de la animación 

	local posicion_nueva = self.direccion_donde_apunta_player * self.velocidad_de_movimiento * dt -- (2)
	local posicion_actual = go.get_position()
	draw_line(posicion_actual, posicion_actual + self.to)


	go.set_position(posicion_actual + posicion_nueva) -- (3)

	if self.embistiendo == false then
		self.direccion_donde_apunta_player = vmath.vector3() -- (4)
	end
	-- 1) Normaliza el vector para el movimiento en diagonal.
	-- 2) Cálculo para nueva posicion en delta time.
	-- 3) Mover al player como resultado de la suma de la posicion actual y la nueva.
	-- 4) Restaurar la dirección del player para cuando ya deje de moverse.

	if self.parado_sobre_vacio == true then
		if self.embistiendo == true or self.parado_sobre_plataforma == true then
			return
		else
			local p = go.get_position()
			go.set_position(vmath.vector3(294,626, p.z))
		end
	end


end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		-- cálculo para resolver la colision del player con las paredes.
		if message.other_group == hash("pared") then
			local newpos = go.get_position() + message.normal * message.distance
			go.set_position(newpos)
		elseif message.other_group == hash("camara") then
			--pprint(message)
			if test == false then
				test = true
				mover_camara (message.other_id, message.other_position, message.normal)
			end
		end
	elseif message_id == hash("trigger_response") then
		if message.enter == true and message.other_group == hash("plataforma") then
			self.parado_sobre_plataforma = true
		elseif message.enter == false and message.other_group == hash("plataforma") then
			self.parado_sobre_plataforma = false
		elseif message.enter == true and message.other_group == hash("vacio") then
			self.parado_sobre_vacio = true
		elseif message.enter == false and message.other_group == hash("vacio") then
			self.parado_sobre_vacio = false
		elseif message.other_group == hash("camara") and message.enter == true then
			pprint(message)
		end
	elseif message_id == hash("rompible_destruido") then
		self.objeto_destruido = true
		self.velocidad_de_movimiento = self.velocidad_por_defecto 
		self.carga_de_embestida = 0 
		self.embistiendo = false 
		msg.post(".", "acquire_input_focus") 
		go.set_position(vmath.vector3(0,0,-0.25), "charge") 
		timer.delay(0.1, false, function() self.objeto_destruido = false end)
	elseif message_id == hash("player_recobra_input") then
		msg.post(".", "acquire_input_focus")
	end
end

function on_input(self, action_id, action)
	if action_id == hash("arriba") then -- input de direcciones "X" e "Y" con sus correspondientes sprites.
	self.direccion_donde_apunta_player.y = 1
	self.ultima_direccion_donde_apunto_player.y = self.direccion_donde_apunta_player.y 
	self.ultima_direccion_donde_apunto_player.x = 0
	self.to = vmath.vector3(0, self.longitud_del_raycast, 0) -- para el draw line
	--sprite.play_flipbook(".", "player_arriba")
elseif action_id == hash("abajo") then
	self.direccion_donde_apunta_player.y = -1
	self.ultima_direccion_donde_apunto_player.y = self.direccion_donde_apunta_player.y 
	self.ultima_direccion_donde_apunto_player.x = 0
	self.to = vmath.vector3(0, -self.longitud_del_raycast, 0)
elseif action_id == hash("izquierda") then
	self.direccion_donde_apunta_player.x = -1
	self.ultima_direccion_donde_apunto_player.x = self.direccion_donde_apunta_player.x 
	self.ultima_direccion_donde_apunto_player.y = 0
	self.to = vmath.vector3(-self.longitud_del_raycast, 0, 0)
	--sprite.play_flipbook(".", "player_izquierda")
elseif action_id == hash("derecha") then
	self.direccion_donde_apunta_player.x = 1
	self.ultima_direccion_donde_apunto_player.x = self.direccion_donde_apunta_player.x
	self.ultima_direccion_donde_apunto_player.y = 0
	self.to = vmath.vector3(self.longitud_del_raycast, 0, 0)
	--sprite.play_flipbook(".", "player_derecha")
elseif action_id == hash("charge") then

	self.embistiendo = true

	if action.released == false then
		self.presionando_tecla_de_embestida = true
		self.carga_de_embestida = self.carga_de_embestida + 1
		--print(self.charge)
		if self.carga_de_embestida >= 50 then

			if self.embestida_cargada_sonido == false then
				self.embestida_cargada_sonido = true
				sound.play("#embestida_cargada")
			end

		elseif self.carga_de_embestida >= 25 then
			if self.sonando_carga_de_embestida == false then
				self.sonando_carga_de_embestida = true
				sound.play("#charging")
				particlefx.play("#charging1")
			end

		end

	elseif action.released == true then
		self.presionando_tecla_de_embestida = false

		if self.carga_de_embestida <= 50 then
			msg.post(".", "release_input_focus")
			self.sonando_carga_de_embestida = false
			sound.stop("#charging")
			particlefx.stop("#charging1")
			self.carga_de_embestida = 0



			if self.direccion_donde_apunta_player == vmath.vector3() then
				self.direccion_donde_apunta_player = self.ultima_direccion_donde_apunto_player
			end

			sound.play("#dash")

			self.velocidad_de_movimiento = 230

			timer.delay(0.1, false,
			function()
				self.velocidad_de_movimiento = self.velocidad_por_defecto
				self.embistiendo = false 
				msg.post(".", "acquire_input_focus")
			end)

		elseif self.carga_de_embestida >= 50 then
			sound.play("#charging_swipe")
			--print("CHARGING!!!")
			msg.post(".", "release_input_focus")
			self.embestida_cargada_sonido = false
			self.sonando_carga_de_embestida = false
			sound.stop("#charging")
			particlefx.stop("#charging1")
			if self.direccion_donde_apunta_player == vmath.vector3() then
				self.direccion_donde_apunta_player = self.ultima_direccion_donde_apunto_player
			end
			go.set_position(self.ultima_direccion_donde_apunto_player * 8, "charge") -- mueve el charge collition
			self.velocidad_de_movimiento = 475

			timer.delay(0.1, false, 
			function()
				if self.objeto_destruido == false then 
					self.velocidad_de_movimiento = self.velocidad_por_defecto 
					self.carga_de_embestida = 0 
					self.embistiendo = false 
					msg.post(".", "acquire_input_focus") 
					go.set_position(vmath.vector3(0,0,-0.25), "charge") 
				end
			end)

		end
	end

elseif action_id == hash("fisicas_debug") and action.pressed then 
	-- "F", prende/apaga el debug de los objetos físicos. 
	msg.post("@system:", "toggle_physics_debug")
elseif action_id == hash("pos") and action.pressed then
	-- Muestra la posicion actual en la consola.
	print(go.get_position())
elseif action_id == hash("accion") and action.pressed then
	local result = physics.raycast(go.get_position(), go.get_position() + self.to, { hash("objeto"), hash("roca") })
	if result then
		self.sonando_carga_de_embestida = false
		sound.stop("#charging")
		particlefx.stop("#charging1")
		self.carga_de_embestida = 0
		msg.post(".", "release_input_focus")
		msg.post(result.id, "player_interactuando_con_objeto", {normal = result.normal})
	end
elseif action_id == hash("inventario") and action.pressed then
	print("--- INVENTARIO ---")
	for k, v in pairs(inventario) do

		print(k .. ":", v)

	end
	print("--- XXXXXXXXXX ---")
end

end

function on_reload(self)
-- Add reload-handling code here
-- Learn more: https://defold.com/manuals/hot-reload/
-- Remove this function if not needed
end
